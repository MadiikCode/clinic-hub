# Импорты из Django и DRF (Django REST Framework)
from rest_framework import viewsets, status, permissions  # Базовые компоненты DRF
# viewsets - для создания ViewSet'ов
# status - HTTP статусы (200, 400 и т.д.)
# permissions - система прав доступа

from rest_framework.response import Response  # Для возврата ответов от API
from rest_framework.decorators import action  # Для кастомных действий в ViewSet'ах
from django.contrib.auth import authenticate  # Для проверки учетных данных
from django.utils import timezone  # Для работы с датами/временем
from django.core.exceptions import ValidationError  # Обработка ошибок валидации
from django.db import transaction  # Для транзакций БД

# Импорт моделей и сериализаторов из текущего приложения
from .models import User, SMSVerification, Appointment
from .serializers import (
    UserSerializer,
    SMSVerificationSerializer,
    AppointmentSerializer,
    LoginSerializer,  # Для входа в систему
    PasswordResetRequestSerializer,  # Для запроса сброса пароля
    PasswordResetConfirmSerializer,  # Для подтверждения сброса пароля
)


class UserViewSet(viewsets.ModelViewSet):
    """
    ViewSet для работы с пользователями.
    Обрабатывает создание, чтение, обновление и удаление пользователей.
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer

    def get_permissions(self):
        """
        Динамические права доступа:
        - Регистрация и верификация доступны всем
        - Остальные действия только аутентифицированным
        """
        if self.action in ['create', 'verify_code', 'reset_password']:
            return [permissions.AllowAny()]
        return [permissions.IsAuthenticated()]

    @action(detail=False, methods=['post'], permission_classes=[permissions.AllowAny])
    def register(self, request):
        """Регистрация нового пользователя с отправкой кода подтверждения"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)  # Проверка данных

        # Транзакция для атомарности операций
        with transaction.atomic():
            user = serializer.save()
            user.set_unusable_password()  # Временный пароль до верификации
            user.save()

            # Генерация и отправка кода подтверждения
            verification = SMSVerification.generate_code(user.email)

        return Response({
            'detail': 'Код подтверждения отправлен',
            'email': user.email
        }, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=['post'], permission_classes=[permissions.AllowAny])
    def login(self, request):
        """Аутентификация пользователя с выдачей JWT токенов"""
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Проверка учетных данных
        user = authenticate(
            email=serializer.validated_data['email'],
            password=serializer.validated_data['password']
        )

        # if not user:
        #     return Response(
        #         {'detail': 'Неверные учетные данные'},
        #         status=status.HTTP_401_UNAUTHORIZED
        #     )

        # # Проверка верификации email
        # if not user.is_verified:
        #     return Response(
        #         {'detail': 'Email не подтвержден'},
        #         status=status.HTTP_403_FORBIDDEN
        #     )

        # # Генерация JWT токенов
        # refresh = RefreshToken.for_user(user)
        # return Response({
        #     'refresh': str(refresh),  # Токен для обновления
        #     'access': str(refresh.access_token),  # Токен доступа
        #     'user': UserSerializer(user).data  # Данные пользователя
        # })


class SMSVerificationViewSet(viewsets.ModelViewSet):
    """
    ViewSet для работы с SMS верификацией.
    Позволяет проверять коды подтверждения.
    """
    queryset = SMSVerification.objects.all()
    serializer_class = SMSVerificationSerializer
    permission_classes = [permissions.AllowAny]  # Доступно всем

    @action(detail=False, methods=['post'])
    def verify_code(self, request):
        #Проверка кода подтверждения
        email = request.data.get('email')
        code = request.data.get('code')

        try:
            verification = SMSVerification.objects.get(
                email=email,
                code=code,
                is_used=False
            )

            if not verification.is_code_valid():
                return Response(
                    {'detail': 'Код истёк или уже использован'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Помечаем код как использованный
            verification.is_used = True
            verification.save()

            # Активируем пользователя
            user = User.objects.get(email=email)
            user.is_verified = True
            user.save()

            return Response(
                {'detail': 'Код подтвержден. Аккаунт активирован.'},
                status=status.HTTP_200_OK
            )

        except SMSVerification.DoesNotExist:
            return Response(
                {'detail': 'Неверный код или email'},
                status=status.HTTP_404_NOT_FOUND
            )


class AppointmentViewSet(viewsets.ModelViewSet):
    """
    ViewSet для работы с записями на прием.
    Обычные пользователи могут только просматривать свои записи.
    Админы - все.
    """
    queryset = Appointment.objects.all()
    serializer_class = AppointmentSerializer

    def get_permissions(self):
        """Права доступа:
        Просмотр: аутентифицированные пользователи
        Изменение: только админы
        """
        if self.action in ['list', 'retrieve']:
            return [permissions.IsAuthenticated()]
        return [permissions.IsAdminUser()]

    def get_queryset(self):
        """Фильтрация записей:
        Пользователи видят только свои записи
        Админы видят все
        """
        qs = super().get_queryset()
        if not self.request.user.is_staff:
            return qs.filter(user=self.request.user)
        return qs

    def perform_create(self, serializer):
        #Автоматическое привязывание записи к текущему пользователю
        serializer.save(user=self.request.user)

    @action(detail=True, methods=['post'])
    def cancel(self, request, pk=None):
        """Отмена записи с проверками:
        - Только владелец или админ может отменять
        - Нельзя отменить прошедшую запись
        """
        appointment = self.get_object()

        # Проверка прав
        if appointment.user != request.user and not request.user.is_staff:
            return Response(
                {'detail': 'Недостаточно прав'},
                status=status.HTTP_403_FORBIDDEN
            )

        # Проверка статуса
        if appointment.status == 'cancelled':
            return Response(
                {'detail': 'Запись уже отменена'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Проверка даты
        if appointment.datetime < timezone.now():
            return Response(
                {'detail': 'Нельзя отменить прошедшую запись'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Отмена записи
        appointment.status = 'cancelled'
        appointment.save()

        return Response(
            {'detail': 'Запись успешно отменена'},
            status=status.HTTP_200_OK
        )